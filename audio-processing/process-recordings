#!/bin/bash

# Audio Recording Processing Utility
# Converts left/top channel to stereo and renames with speaker/description

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

usage() {
    echo "Usage: process-recordings <input-files...> <output-directory>"
    echo ""
    echo "Example:"
    echo "  process-recordings /media/johncornish/2C32-CEEB/RECORD/*.mp3 ~/Dropbox/recordings/"
    echo ""
    echo "Input filename format: MM-DD-YYYY-HH-MM-SS.MP3"
    echo "Output filename format: MM-DD NN {speakers} - {description}.mp3"
    exit 1
}

# Check for minimum arguments
if [ $# -lt 2 ]; then
    usage
fi

# Get output directory (last argument)
OUTPUT_DIR="${@: -1}"

# Get input files (all arguments except last)
INPUT_FILES=("${@:1:$#-1}")

# Validate output directory
if [ ! -d "$OUTPUT_DIR" ]; then
    echo -e "${YELLOW}Output directory does not exist. Creating: $OUTPUT_DIR${NC}"
    mkdir -p "$OUTPUT_DIR"
fi

# Check for ffmpeg
if ! command -v ffmpeg &> /dev/null; then
    echo -e "${RED}Error: ffmpeg is required but not installed.${NC}"
    exit 1
fi

# Check for ffplay (optional)
HAS_FFPLAY=false
if command -v ffplay &> /dev/null; then
    HAS_FFPLAY=true
fi

# Function to extract date components from filename
# Input format: MM-DD-YYYY-HH-MM-SS.MP3
parse_filename() {
    local filename="$1"
    local basename=$(basename "$filename")

    # Extract components using regex
    if [[ "$basename" =~ ^([0-9]{2})-([0-9]{2})-([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})\.[mM][pP]3$ ]]; then
        MONTH="${BASH_REMATCH[1]}"
        DAY="${BASH_REMATCH[2]}"
        YEAR="${BASH_REMATCH[3]}"
        HOUR="${BASH_REMATCH[4]}"
        MINUTE="${BASH_REMATCH[5]}"
        SECOND="${BASH_REMATCH[6]}"
        DATE_PREFIX="$MONTH-$DAY"
        SORT_KEY="$YEAR-$MONTH-$DAY-$HOUR-$MINUTE-$SECOND"
        return 0
    else
        return 1
    fi
}

# Function to sanitize filename
sanitize_filename() {
    local name="$1"
    # Remove/replace problematic characters
    echo "$name" | sed 's/[<>:"/\\|?*]//g' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//'
}

# Collect and validate input files
declare -a VALID_FILES
declare -A FILE_DATES
declare -A FILE_SORT_KEYS

echo -e "${BLUE}Scanning input files...${NC}"

for file in "${INPUT_FILES[@]}"; do
    if [ ! -f "$file" ]; then
        echo -e "${YELLOW}Warning: Skipping non-existent file: $file${NC}"
        continue
    fi

    if parse_filename "$file"; then
        VALID_FILES+=("$file")
        FILE_DATES["$file"]="$DATE_PREFIX"
        FILE_SORT_KEYS["$file"]="$SORT_KEY"
    else
        echo -e "${YELLOW}Warning: Skipping file with unexpected format: $(basename "$file")${NC}"
        echo "  Expected format: MM-DD-YYYY-HH-MM-SS.MP3"
    fi
done

if [ ${#VALID_FILES[@]} -eq 0 ]; then
    echo -e "${RED}No valid input files found.${NC}"
    exit 1
fi

echo -e "${GREEN}Found ${#VALID_FILES[@]} valid file(s)${NC}"
echo ""

# Sort files by sort key (timestamp)
IFS=$'\n' SORTED_FILES=($(for file in "${VALID_FILES[@]}"; do
    echo "${FILE_SORT_KEYS[$file]}|$file"
done | sort | cut -d'|' -f2))
unset IFS

# Calculate sequence numbers within each date
declare -A DATE_COUNTS
declare -A FILE_SEQ_NUMS

for file in "${SORTED_FILES[@]}"; do
    date="${FILE_DATES[$file]}"
    if [ -z "${DATE_COUNTS[$date]}" ]; then
        DATE_COUNTS["$date"]=1
    else
        DATE_COUNTS["$date"]=$((DATE_COUNTS["$date"] + 1))
    fi
    FILE_SEQ_NUMS["$file"]=$(printf "%02d" "${DATE_COUNTS[$date]}")
done

# Process each file
TOTAL=${#SORTED_FILES[@]}
CURRENT=0

for file in "${SORTED_FILES[@]}"; do
    CURRENT=$((CURRENT + 1))
    basename_file=$(basename "$file")
    date_prefix="${FILE_DATES[$file]}"
    seq_num="${FILE_SEQ_NUMS[$file]}"

    echo ""
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
    echo -e "${GREEN}File $CURRENT/$TOTAL:${NC} $basename_file → ${date_prefix} ${seq_num} ..."
    echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"

    # Play audio preview (first 10 seconds)
    if [ "$HAS_FFPLAY" = true ]; then
        echo -e "${YELLOW}Playing 10-second preview (press 'q' to stop)...${NC}"
        ffplay -nodisp -autoexit -t 10 "$file" 2>/dev/null || true
    else
        echo -e "${YELLOW}(ffplay not available, skipping audio preview)${NC}"
    fi

    # Prompt for speakers
    echo ""
    read -p "Enter speaker(s) (e.g., Mike): " speakers
    speakers=$(sanitize_filename "$speakers")

    if [ -z "$speakers" ]; then
        echo -e "${YELLOW}No speakers entered, using 'Unknown'${NC}"
        speakers="Unknown"
    fi

    # Prompt for description
    read -p "Enter description: " description
    description=$(sanitize_filename "$description")

    if [ -z "$description" ]; then
        echo -e "${YELLOW}No description entered, using 'Untitled'${NC}"
        description="Untitled"
    fi

    # Build output filename
    output_filename="${date_prefix} ${seq_num} ${speakers} - ${description}.mp3"
    output_path="$OUTPUT_DIR/$output_filename"

    echo ""
    echo -e "${BLUE}Output:${NC} $output_filename"

    # Process with FFmpeg
    echo -e "${YELLOW}Processing audio...${NC}"
    if ffmpeg -i "$file" -af "pan=stereo|c0=c0|c1=c0" -y "$output_path" 2>/dev/null; then
        # Verify output file
        if [ -f "$output_path" ] && [ -s "$output_path" ]; then
            echo -e "${GREEN}Successfully created: $output_filename${NC}"

            # Prompt for deletion
            echo ""
            read -p "Delete original file? [y/N]: " delete_confirm
            if [[ "$delete_confirm" =~ ^[Yy]$ ]]; then
                rm "$file"
                echo -e "${GREEN}Deleted: $basename_file${NC}"
            else
                echo -e "${YELLOW}Kept original: $basename_file${NC}"
            fi
        else
            echo -e "${RED}Error: Output file is empty or missing${NC}"
        fi
    else
        echo -e "${RED}Error: FFmpeg processing failed${NC}"
    fi
done

echo ""
echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${GREEN}Processing complete! Processed $TOTAL file(s).${NC}"
echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
