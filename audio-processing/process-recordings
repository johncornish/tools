#!/bin/bash

# Audio Recording Processing Utility
# Converts left/top channel to stereo and renames with speaker/description

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

usage() {
    echo "Usage: process-recordings <input-files...> <output-directory>"
    echo ""
    echo "Example:"
    echo "  process-recordings /media/johncornish/2C32-CEEB/RECORD/*.mp3 ~/Dropbox/recordings/"
    echo ""
    echo "Input filename format: MM-DD-YYYY-HH-MM-SS.MP3"
    echo "Output filename format: MM-DD NN {speakers} - {description}.mp3"
    exit 1
}

# Check for minimum arguments
if [ $# -lt 2 ]; then
    usage
fi

# Get output directory (last argument)
OUTPUT_DIR="${@: -1}"

# Get input files (all arguments except last)
INPUT_FILES=("${@:1:$#-1}")

# Validate output directory
if [ ! -d "$OUTPUT_DIR" ]; then
    echo -e "${YELLOW}Output directory does not exist. Creating: $OUTPUT_DIR${NC}"
    mkdir -p "$OUTPUT_DIR"
fi

# Check for ffmpeg
if ! command -v ffmpeg &> /dev/null; then
    echo -e "${RED}Error: ffmpeg is required but not installed.${NC}"
    exit 1
fi

# Check for ffplay (optional)
HAS_FFPLAY=false
if command -v ffplay &> /dev/null; then
    HAS_FFPLAY=true
fi

# Function to extract date components from filename
# Input format: MM-DD-YYYY-HH-MM-SS.MP3
parse_filename() {
    local filename="$1"
    local basename=$(basename "$filename")

    # Extract components using regex
    if [[ "$basename" =~ ^([0-9]{2})-([0-9]{2})-([0-9]{4})-([0-9]{2})-([0-9]{2})-([0-9]{2})\.[mM][pP]3$ ]]; then
        MONTH="${BASH_REMATCH[1]}"
        DAY="${BASH_REMATCH[2]}"
        YEAR="${BASH_REMATCH[3]}"
        HOUR="${BASH_REMATCH[4]}"
        MINUTE="${BASH_REMATCH[5]}"
        SECOND="${BASH_REMATCH[6]}"
        DATE_PREFIX="$MONTH-$DAY"
        SORT_KEY="$YEAR-$MONTH-$DAY-$HOUR-$MINUTE-$SECOND"
        return 0
    else
        return 1
    fi
}

# Function to sanitize filename
sanitize_filename() {
    local name="$1"
    # Remove/replace problematic characters
    echo "$name" | sed 's/[<>:"/\\|?*]//g' | sed 's/  */ /g' | sed 's/^ *//;s/ *$//'
}

# Collect and validate input files
declare -a VALID_FILES
declare -A FILE_DATES
declare -A FILE_SORT_KEYS

echo -e "${BLUE}Scanning input files...${NC}"

for file in "${INPUT_FILES[@]}"; do
    if [ ! -f "$file" ]; then
        echo -e "${YELLOW}Warning: Skipping non-existent file: $file${NC}"
        continue
    fi

    if parse_filename "$file"; then
        VALID_FILES+=("$file")
        FILE_DATES["$file"]="$DATE_PREFIX"
        FILE_SORT_KEYS["$file"]="$SORT_KEY"
    else
        echo -e "${YELLOW}Warning: Skipping file with unexpected format: $(basename "$file")${NC}"
        echo "  Expected format: MM-DD-YYYY-HH-MM-SS.MP3"
    fi
done

if [ ${#VALID_FILES[@]} -eq 0 ]; then
    echo -e "${RED}No valid input files found.${NC}"
    exit 1
fi

echo -e "${GREEN}Found ${#VALID_FILES[@]} valid file(s)${NC}"
echo ""

# Sort files by sort key (timestamp)
IFS=$'\n' SORTED_FILES=($(for file in "${VALID_FILES[@]}"; do
    echo "${FILE_SORT_KEYS[$file]}|$file"
done | sort | cut -d'|' -f2))
unset IFS

# Calculate sequence numbers within each date
declare -A DATE_COUNTS
declare -A FILE_SEQ_NUMS

for file in "${SORTED_FILES[@]}"; do
    date="${FILE_DATES[$file]}"
    if [ -z "${DATE_COUNTS[$date]}" ]; then
        DATE_COUNTS["$date"]=1
    else
        DATE_COUNTS["$date"]=$((DATE_COUNTS["$date"] + 1))
    fi
    FILE_SEQ_NUMS["$file"]=$(printf "%02d" "${DATE_COUNTS[$date]}")
done

# Data structures for queued processing
declare -A FILE_SPEAKERS
declare -A FILE_DESCRIPTIONS
declare -A FILE_SKIPPED
declare -a QUEUED_FILES

TOTAL=${#SORTED_FILES[@]}

# ═══════════════════════════════════════════════════════════════
# PHASE 1: Preview & Name (fast, interactive)
# ═══════════════════════════════════════════════════════════════
echo ""
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${BLUE}PHASE 1: Preview & Name Files${NC}"
echo -e "${BLUE}Press Enter to skip naming a file${NC}"
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"

CURRENT=0
for file in "${SORTED_FILES[@]}"; do
    CURRENT=$((CURRENT + 1))
    basename_file=$(basename "$file")
    date_prefix="${FILE_DATES[$file]}"
    seq_num="${FILE_SEQ_NUMS[$file]}"

    echo ""
    echo -e "${GREEN}[$CURRENT/$TOTAL]${NC} $basename_file → ${date_prefix} ${seq_num} ..."

    # Play audio preview (first 10 seconds)
    if [ "$HAS_FFPLAY" = true ]; then
        echo -e "${YELLOW}Playing 10-second preview (press 'q' to stop)...${NC}"
        ffplay -nodisp -autoexit -t 10 "$file" 2>/dev/null || true
    else
        echo -e "${YELLOW}(ffplay not available, skipping audio preview)${NC}"
    fi

    # Prompt for speaker
    read -p "Speaker (Enter to skip): " speaker
    speaker=$(sanitize_filename "$speaker")

    if [ -z "$speaker" ]; then
        # Skip naming - mark as skipped
        FILE_SKIPPED["$file"]=1
        FILE_SPEAKERS["$file"]="Unknown"
        FILE_DESCRIPTIONS["$file"]=""
        echo -e "${YELLOW}Skipped - will save as Unknown${NC}"
    else
        # Named file - optionally get description
        FILE_SKIPPED["$file"]=0
        FILE_SPEAKERS["$file"]="$speaker"
        read -p "Description (optional): " description
        description=$(sanitize_filename "$description")
        FILE_DESCRIPTIONS["$file"]="$description"
    fi

    QUEUED_FILES+=("$file")
done

# ═══════════════════════════════════════════════════════════════
# PHASE 2: Queue Summary
# ═══════════════════════════════════════════════════════════════
echo ""
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${BLUE}PHASE 2: Queue Summary${NC}"
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo ""

NAMED_COUNT=0
SKIPPED_COUNT=0

for file in "${QUEUED_FILES[@]}"; do
    date_prefix="${FILE_DATES[$file]}"
    seq_num="${FILE_SEQ_NUMS[$file]}"
    speaker="${FILE_SPEAKERS[$file]}"
    description="${FILE_DESCRIPTIONS[$file]}"

    if [ "${FILE_SKIPPED[$file]}" = "1" ]; then
        output_filename="${date_prefix} ${seq_num} Unknown.mp3"
        echo -e "  ${YELLOW}[SKIP]${NC} $output_filename"
        SKIPPED_COUNT=$((SKIPPED_COUNT + 1))
    else
        if [ -n "$description" ]; then
            output_filename="${date_prefix} ${seq_num} ${speaker} - ${description}.mp3"
        else
            output_filename="${date_prefix} ${seq_num} ${speaker}.mp3"
        fi
        echo -e "  ${GREEN}[NAME]${NC} $output_filename"
        NAMED_COUNT=$((NAMED_COUNT + 1))
    fi
done

echo ""
echo -e "Named: ${GREEN}$NAMED_COUNT${NC} | Skipped: ${YELLOW}$SKIPPED_COUNT${NC} | Total: $TOTAL"
echo ""

# Deletion preference prompt
read -p "Delete originals after processing? [y/N]: " delete_all
DELETE_ORIGINALS=false
if [[ "$delete_all" =~ ^[Yy]$ ]]; then
    DELETE_ORIGINALS=true
    echo -e "${YELLOW}Will delete originals after successful processing${NC}"
else
    echo -e "${GREEN}Will keep original files${NC}"
fi

echo ""
read -p "Press Enter to start batch processing..."

# ═══════════════════════════════════════════════════════════════
# PHASE 3: Batch Processing (hands-off)
# ═══════════════════════════════════════════════════════════════
echo ""
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${BLUE}PHASE 3: Batch Processing${NC}"
echo -e "${BLUE}═══════════════════════════════════════════════════════════════${NC}"

SUCCESS_COUNT=0
FAIL_COUNT=0
DELETED_COUNT=0
declare -a FAILED_FILES

CURRENT=0
for file in "${QUEUED_FILES[@]}"; do
    CURRENT=$((CURRENT + 1))
    basename_file=$(basename "$file")
    date_prefix="${FILE_DATES[$file]}"
    seq_num="${FILE_SEQ_NUMS[$file]}"
    speaker="${FILE_SPEAKERS[$file]}"
    description="${FILE_DESCRIPTIONS[$file]}"

    # Build output filename
    if [ "${FILE_SKIPPED[$file]}" = "1" ]; then
        output_filename="${date_prefix} ${seq_num} Unknown.mp3"
    elif [ -n "$description" ]; then
        output_filename="${date_prefix} ${seq_num} ${speaker} - ${description}.mp3"
    else
        output_filename="${date_prefix} ${seq_num} ${speaker}.mp3"
    fi
    output_path="$OUTPUT_DIR/$output_filename"

    echo -ne "[$CURRENT/$TOTAL] Processing: $output_filename... "

    # Process with FFmpeg
    if ffmpeg -i "$file" -af "pan=stereo|c0=c0|c1=c0" -y "$output_path" 2>/dev/null; then
        # Verify output file
        if [ -f "$output_path" ] && [ -s "$output_path" ]; then
            echo -e "${GREEN}OK${NC}"
            SUCCESS_COUNT=$((SUCCESS_COUNT + 1))

            # Delete original if requested
            if [ "$DELETE_ORIGINALS" = true ]; then
                rm "$file"
                DELETED_COUNT=$((DELETED_COUNT + 1))
            fi
        else
            echo -e "${RED}FAILED (empty output)${NC}"
            FAIL_COUNT=$((FAIL_COUNT + 1))
            FAILED_FILES+=("$basename_file")
        fi
    else
        echo -e "${RED}FAILED${NC}"
        FAIL_COUNT=$((FAIL_COUNT + 1))
        FAILED_FILES+=("$basename_file")
    fi
done

# ═══════════════════════════════════════════════════════════════
# Final Summary
# ═══════════════════════════════════════════════════════════════
echo ""
echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
echo -e "${GREEN}Processing Complete!${NC}"
echo -e "${GREEN}═══════════════════════════════════════════════════════════════${NC}"
echo ""
echo -e "  Successful: ${GREEN}$SUCCESS_COUNT${NC}"
echo -e "  Failed:     ${RED}$FAIL_COUNT${NC}"
if [ "$DELETE_ORIGINALS" = true ]; then
    echo -e "  Deleted:    ${YELLOW}$DELETED_COUNT${NC} original(s)"
fi

if [ ${#FAILED_FILES[@]} -gt 0 ]; then
    echo ""
    echo -e "${RED}Failed files:${NC}"
    for failed in "${FAILED_FILES[@]}"; do
        echo "  - $failed"
    done
fi
